#!/usr/bin/perl -w
use strict; 

use IO::Socket::INET;


#****h* kpo/se2graphite.pl
# NAME
#  se2graphite.pl
#
# SYNOPSIS
# This script will put the data of all finished pos log files.
#  and then remove the log file.
#
#  One of the primary concerns here is that this script must be able to run for years on end, without failing.
#   So no memory leaks.
#
# EXAMPLE
#  
#
# SEE ALSO
# 
# TODO
#  
#
# robodoc --src xml2web.pl --doc doc --singlefile --html
#****



# Barf about everything.
use strict;

use FindBin;
use lib ( "$FindBin::Bin" );

use XML::Simple;

use Data::Dumper;

# ==============================================================================
#                              V A R I A B L E S
# ==============================================================================

# By default the base path is empty.
my $f_szBasePath="";

# TODO C Enable reading the information from a config file and cli. 
my $f_szCarbonServer = '10.0.3.199';
my $f_szCarbonPort = 2003;

my $szCliParm = shift;


if ( defined($szCliParm) &&  ( $szCliParm eq "-b" ) ) {
  # Pick the next parameter in the list.
  $f_szBasePath = shift;

  # remove any newline char.
  chomp($f_szBasePath);

  if ( ! -d $f_szBasePath ) {
    die("!!! Directory does not exist: $f_szBasePath\n     Possibly look in the gz_import SMF (pos_gz_import,xml) at the '-b' parm change.");
  }
} # endif -b parm

if ( defined($szCliParm) &&  ( $szCliParm eq "-p" ) ) {
  # Pick the next parameter in the list.
  my $szPidFile = shift;

  # remove any newline char.
  chomp($szPidFile);

  if ( defined($szPidFile) && ($szPidFile !~ /^-/) ) {
    `echo "$$" > $szPidFile`; 
  } else {
    die("-p was given, but there is no valid pid filename following it.");
  } # endif pidfile is active
} # endif -p parm


#****v* se2graphite.pl/f_szRrdToolCmd
# DESCRIPTION
#  The full path and command to access the graphitetool cmd.
#  
# SEE ALSO
#  RrdCommit
# SOURCE
# The LD_LIBRARY_PATH is used to use the gcc lib provided by Sun.
$ENV{LD_LIBRARY_PATH}="${f_szBasePath}/usr/sfw/lib:${f_szBasePath}/usr/local/graphitetool-1.2.19/lib";
#my $f_szRrdToolCmd="${f_szBasePath}/usr/local/graphitetool-1.2.19/bin/graphitetool";
my $f_szRrdToolCmd="graphitetool";
#****


#****v* /f_hFailFiles
# DESCRIPTION
#  Hold the list of files that has XML syntax errors.
#   The files in the list must be removed.
#   The entries in the list must be removed when the file has been 
#    deleted, so as to avoid memory leaks.
#  
# SEE ALSO
#  CleanInvalidFiles
# SOURCE
my %f_hFailFiles;
#****



#****v* se2graphite.pl/f_szBaseDirDataFiles
# DESCRIPTION
#  Path where the data xml files are stored by the collector.
#  
# SEE ALSO
#  ImportCollectorData
# SOURCE
my $f_szBaseDirDataFiles="${f_szBasePath}/var/tmp";
#****




#****v* se2graphite.pl/f_szDataFileNameTemplate
# DESCRIPTION
#  Template used for identifying the files generated by the collector.
#  
# SEE ALSO
#  ImportCollectorData
# SOURCE
my $f_szDataFileNameTemplate="pos_*.xml";
#****




#****v* se2graphite.pl/f_nDelayBetweenImports
# DESCRIPTION
#  How long to wait between the end of one import and the start of the next.
# Wait 5 minutes after last import.
# SEE ALSO
#  main
# SOURCE
my $f_nDelayBetweenImports=5*60;
#****


# ==============================================================================
#                               F U N C T I O N S
# ==============================================================================

sub MakeArrayRef {
  my $szVar=shift;
  if ( ! defined $szVar ) {
    return [];
  }
  if ( ref($szVar) eq "ARRAY" ) {
    print "MakeArrayRef() it was already an array.\n";
    return $szVar;
  }
  print "Making it an array\n";
  return [$szVar];
} # end makearrayref



# ----------------------------------------------------------------------------
#****f* se2graphite.pl/ProcessData
# NAME
#   ProcessData
# FUNCTION
#  
#  
# EXAMPLE
#  
#
# INPUTS
#   *  -- .
#
# OUTPUT
#
# 
# RETURN
#
#
# SEE ALSO
#  
# TODO
#  
#
# SOURCE
sub ProcessData {
    my $xmlRootNode = shift;


    # TODO V concider using PICKLE for a more effiecient transfer.

    my $sock = IO::Socket::INET->new(
        PeerAddr => $f_szCarbonServer,
        PeerPort => $f_szCarbonPort,
        Proto    => 'tcp'
    );

    die "!!! Connection not created." unless(defined($sock));

    die "Unable to connect: $!\n" unless ($sock->connected);


    #print Dumper($xmlRootNode);
    my $szRrdtoolCmd;
    my $szValueList;
    # Foreach dataset
    # A data set is from a specific, unique time.
    # TODO V Be able to handle if there is only a single DataSet entry.
    foreach my $xmlDataSetNode (@{$xmlRootNode->{DataSet}}) {
	#print Dumper($xmlDataSetNode);

        # Get the time stamp
	my $nTimeStamp=$xmlDataSetNode->{TimeStamp};

        $szValueList="$nTimeStamp";
        $szRrdtoolCmd.= " --template ";

	my $szSepperatorChar='';
        # foreach data pair/entry
        # TODO C change cpu to entry or something.
        #print Dumper($xmlDataSetNode->{cpu});
        my @arCpuList;
        if ( ref($xmlDataSetNode->{cpu}) eq "ARRAY" ) {
          @arCpuList = @{$xmlDataSetNode->{cpu}};
        } else {
          #  print "not an ARRAY\n";
          push(@arCpuList, $xmlDataSetNode->{cpu});
        }
        #print "=== First entry type in CPU list ===" . ref($arCpuList[0]) ."\n";
        #print Dumper($arCpuList[0]);
	#foreach my $xmlDataEntry (@{$xmlDataSetNode->{cpu}}) {
	foreach my $xmlDataEntry (@arCpuList) {
            my $szNameKey="Name";
            #print "-------------\n";
	    #print Dumper($xmlDataEntry);
	    my $szName=$xmlDataEntry->{$szNameKey};
            #print "DDD Name: $szName\n";
# TODO V concider some other way of handling the groups without names.
            if ( $szName eq "" ) {
              $szName = "gen";
            }
            # get key list from xmlDataEntry
            foreach my $szKey (keys %{$xmlDataEntry} ) {
		if ( $szKey ne $szNameKey ) {
		    $szRrdtoolCmd .= $szSepperatorChar;
                    # only if name is defined.
 		    if ( $szName ne "" ){
			$szRrdtoolCmd .= $szName . "_";
		    } # endif name defined.
		    $szRrdtoolCmd .= "${szKey}";
		  $szValueList .= ":" . "$xmlDataEntry->{$szKey}";
		  #print "$szKey => $xmlDataEntry->{$szKey}\n";
                  print "machine.alpha.$szName.$szKey $xmlDataEntry->{$szKey} $nTimeStamp\n";
                  $sock->send("machine.alpha.$szName.$szKey $xmlDataEntry->{$szKey} $nTimeStamp\n");
                  # Sepperator needed from now on.
                  #  Its faster to just assign it than iffing it. (I think)
                  $szSepperatorChar=':';
		} # end if not the name key.
	    } # end foreach key
	} # end foreach data entry.
       # Commit the graphite change.
    } # end foreach dataset
  $sock->shutdown(2);
} # end processdata
#****



# ----------------------------------------------------------------------------
#****f* se2graphite.pl/ImportCollectorData
# NAME
#   ImportCollectorData
# FUNCTION
#  
#  
# EXAMPLE
#  
#
# INPUTS
#   *  -- .
#
# OUTPUT
#
# 
# RETURN
#
#
# SEE ALSO
#  
# TODO
#  
#
# SOURCE
sub ImportCollectorData {

  # List all /var/tmp/eucaluptus.xml files.
  my @arFileList=`ls -1 $f_szBaseDirDataFiles/$f_szDataFileNameTemplate`;

  # TODO N Ensure there are data in the list to pop.
  # This is the last in the list
  my $szPostponeThis=pop(@arFileList);

  # Sort in alphabeticall order, then only the latest shouldnt be handled.
  #  Then all other handled files can be removed once the data has been imported.

  # For each file
  foreach my $szFileName (@arFileList) {
      # remove newline etc from line.
      chomp($szFileName);
      #printf "--- $szFileName\n";

      # if the size is zero then remove the file.
      # open
      my $xmlRootNode = eval { XMLin($szFileName) };
      if($@) {
          chomp($@);
	  printf "III $szFileName $@\n";
          if ( exists($f_hFailFiles{$szFileName}) ) {
            $f_hFailFiles{$szFileName}++;
          } else {
            $f_hFailFiles{$szFileName}=0;
          }
      } else {
        # process
	  # printf "+++ Processing: $szFileName\n";
	  ProcessData($xmlRootNode);
        # close
        # TODO V Only delete when processing was succesful.
        unlink($szFileName);
      } # endif xmlin.
  } # end foreach file.

} # end importcollectordata
#****



# ----------------------------------------------------------------------------
#****f* se2graphite.pl/CleanInvalidFiles
# NAME
#   CleanInvalidFiles
# FUNCTION
#  
#  
# EXAMPLE
#  
#
# INPUTS
#   *  -- .
#
# OUTPUT
#
# 
# RETURN
#
#
# SEE ALSO
#  
# TODO
#  
#
# SOURCE
sub CleanInvalidFiles {
  foreach my $szFileName ( keys %f_hFailFiles ) {
    if ( $f_hFailFiles{$szFileName} > 1 ) {
      # remove the file.
      unlink($szFileName);
      # remove the entry from the hash.
      delete($f_hFailFiles{$szFileName});
    } # endif too many itterations where file has failed.
  } # end foreach failed filename.
} # end cleaninvalidfiles
#****


# ==============================================================================
                #     #    #      ###   #     #
                ##   ##   # #      #    ##    #
                # # # #  #   #     #    # #   #
                #  #  # #     #    #    #  #  #
                #     # #######    #    #   # #
                #     # #     #    #    #    ##
                #     # #     #   ###   #     #
# ==============================================================================

  # Loop forever;
  while (1) {
    # Import data and send it to graphite.
    ImportCollectorData();

    # remove files that has had syntax errors.
    CleanInvalidFiles();

    # sleep
    sleep($f_nDelayBetweenImports);
  } # end while.
